import 'dart:io';
import 'dart:convert';
import 'package:args/args.dart';

const String _defaultOutputPath = 'lib/core/theme/generated_theme.dart';

void main(List<String> arguments) async {
  final parser = ArgParser()
    ..addOption('config', abbr: 'c', help: 'Path to the theme JSON configuration file. If not provided, BaseTheme will be used.')
    ..addOption('output', abbr: 'o', help: 'Path to output the generated Dart theme file.', defaultsTo: _defaultOutputPath);

  ArgResults argResults;
  try {
    argResults = parser.parse(arguments);
  } catch (e) {
    stderr.writeln('Error parsing arguments: ${e.toString()}');
    stderr.writeln(parser.usage);
    exitCode = 1;
    return;
  }

  final configPath = argResults['config'] as String?;
  final outputPath = argResults['output'] as String;

  String generatedCode;

  if (configPath != null && configPath.isNotEmpty) {
    final configFile = File(configPath);
    if (!await configFile.exists()) {
      stderr.writeln('Error: Configuration file not found at $configPath');
      exitCode = 1;
      return;
    }
    try {
      final String jsonString = await configFile.readAsString();
      final Map<String, dynamic> themeConfig = jsonDecode(jsonString);
      _validateThemeConfig(themeConfig);
      generatedCode = _generateDartThemeClassFromConfig(themeConfig);
      stdout.writeln('Successfully generated theme file at $outputPath based on configuration from $configPath');
    } catch (e, s) {
      stderr.writeln('An error occurred during theme generation from config: ${e.toString()}');
      stderr.writeln('Stack trace: \n$s');
      exitCode = 1;
      return;
    }
  } else {
    generatedCode = _generateBaseThemeWrapper();
    stdout.writeln('No config path provided. Successfully generated theme file at $outputPath to use BaseTheme.');
  }
  
  try {
    final outputFile = File(outputPath);
    await outputFile.create(recursive: true);
    await outputFile.writeAsString(generatedCode);
  } catch (e,s) {
    stderr.writeln('An error occurred while writing the output file: ${e.toString()}');
    stderr.writeln('Stack trace: \n$s');
    exitCode = 1;
    return;
  }
}

void _validateThemeConfig(Map<String, dynamic> config) {
  final requiredKeys = ['themeName', 'brightness', 'primaryColor', 'colorScheme', 'textTheme'];
  for (final key in requiredKeys) {
    if (!config.containsKey(key) || config[key] == null) {
      throw FormatException('Invalid theme configuration: Missing or null required key "$key". Config: $config');
    }
  }
  if (config['colorScheme'] is! Map) throw FormatException('Invalid theme configuration: "colorScheme" must be an object. Config: $config');
  if (config['textTheme'] is! Map) throw FormatException('Invalid theme configuration: "textTheme" must be an object. Config: $config');
  _parseColorHexValue(config['primaryColor'] as String?, keyName: 'primaryColor');
}

int _parseColorHexValue(String? hexString, {String defaultHex = '#FFFFFFFF', String keyName = 'color'}) {
  if (hexString == null || hexString.isEmpty) hexString = defaultHex;
  String parsableHex = hexString.toUpperCase().replaceFirst('#', '');
  if (parsableHex.length == 6) parsableHex = 'FF$parsableHex';
  if (parsableHex.length != 8) {
    throw FormatException('Invalid hex color format for $keyName: "$hexString". Expected 6 or 8 hex digits (with optional #). Parsed as $parsableHex');
  }
  try {
    return int.parse(parsableHex, radix: 16);
  } catch (e) {
    throw FormatException('Error parsing hex color for $keyName: "$hexString" -> $parsableHex. ${e.toString()}');
  }
}

String _generateBaseThemeWrapper() {
  return '''
// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by tool/generate_theme.dart (using BaseTheme fallback)

import 'package:flutter/material.dart';
import 'package:flutterui/core/theme/app_theme.dart';
import 'package:flutterui/core/theme/base_theme.dart'; // Import the actual BaseTheme

class AppGeneratedTheme implements AppTheme {
  final BaseTheme _baseTheme = const BaseTheme();

  const AppGeneratedTheme();

  @override
  String get name => _baseTheme.name;

  @override
  String get brandingMessage => _baseTheme.brandingMessage;

  @override
  String get logo => _baseTheme.logo;

  @override
  String get logoIcon => _baseTheme.logoIcon;

  @override
  ThemeData get themeData => _baseTheme.themeData;
}
''';
}

String _generateDartThemeClassFromConfig(Map<String, dynamic> config) {
  const String className = 'AppGeneratedTheme'; 
  final themeName = config['themeName'] as String;

  final brandingMessage = config['brandingMessage'] as String? ?? 'Welcome';
  
  final String baseAssetPath = 'assets/';
  final String configLogoPath = config['logoPath'] as String? ?? 'default_logo.png';
  final String configLogoIconPath = config['logoIconPath'] as String? ?? 'default_icon.png';
  
  final logoPath = configLogoPath.startsWith('assets/') ? configLogoPath : baseAssetPath + configLogoPath;
  final logoIconPath = configLogoIconPath.startsWith('assets/') ? configLogoIconPath : baseAssetPath + configLogoIconPath;

  final fontFamily = config['fontFamily'] as String?;
  final useMaterial3 = config['useMaterial3'] as bool? ?? true;
  
  final brightnessStr = config['brightness'] as String? ?? 'light';
  final brightness = brightnessStr == 'dark' ? 'Brightness.dark' : 'Brightness.light';

  final primaryColorHex = config['primaryColor'] as String? ?? '#0000FF';
  final scaffoldBackgroundColorHex = config['scaffoldBackgroundColor'] as String?;

  final extensionsConfig = config['extensions'] as Map<String, dynamic>?;
  final customColorsConfig = extensionsConfig?['customColors'] as Map<String, dynamic>?;
  final brandingSurfaceHex = customColorsConfig?['brandingSurface'] as String?;

  final colorSchemeConfig = config['colorScheme'] as Map<String, dynamic>;
  final textThemeConfig = config['textTheme'] as Map<String, dynamic>;
  
  final appBarThemeConfig = config['appBarTheme'] as Map<String, dynamic>?;
  final cardThemeConfig = config['cardTheme'] as Map<String, dynamic>?;
  final elevatedButtonThemeConfig = config['elevatedButtonTheme'] as Map<String, dynamic>?;
  final textButtonThemeConfig = config['textButtonTheme'] as Map<String, dynamic>?;
  final outlinedButtonThemeConfig = config['outlinedButtonTheme'] as Map<String, dynamic>?;
  final inputDecorationThemeConfig = config['inputDecorationTheme'] as Map<String, dynamic>?;
  final dialogThemeConfig = config['dialogTheme'] as Map<String, dynamic>?;
  final snackBarThemeConfig = config['snackBarTheme'] as Map<String, dynamic>?;
  final iconThemeConfig = config['iconTheme'] as Map<String, dynamic>?;
  final dividerThemeConfig = config['dividerTheme'] as Map<String, dynamic>?;


  final buffer = StringBuffer();
  buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
  buffer.writeln('// Generated by tool/generate_theme.dart');
  buffer.writeln('// Based on config: $themeName\n');
  buffer.writeln("import 'package:flutter/material.dart';");
  buffer.writeln("import 'package:flutterui/core/theme/app_theme.dart'; // For AppTheme and CustomColors\n");

  buffer.writeln('class $className implements AppTheme {');
  buffer.writeln('  const $className();\n');
  buffer.writeln('  @override String get name => "$themeName";');
  buffer.writeln('  @override String get brandingMessage => "$brandingMessage";');
  buffer.writeln('  @override String get logo => "$logoPath";');
  buffer.writeln('  @override String get logoIcon => "$logoIconPath";\n');

  buffer.writeln('  @override ThemeData get themeData {');
  buffer.writeln('    return ThemeData(');
  buffer.writeln('      brightness: $brightness,');
  buffer.writeln('      primaryColor: ${_colorToCode(primaryColorHex)},');
  if (scaffoldBackgroundColorHex != null) {
    buffer.writeln('      scaffoldBackgroundColor: ${_colorToCode(scaffoldBackgroundColorHex)},');
  }
  if (fontFamily != null) {
    buffer.writeln('      fontFamily: "$fontFamily",');
  }
  buffer.writeln('      useMaterial3: $useMaterial3,');

  buffer.writeln('      colorScheme: ColorScheme(');
  buffer.writeln('        brightness: $brightness,');
  buffer.writeln('        primary: ${_colorToCode(colorSchemeConfig['primary'] as String?)},');
  buffer.writeln('        onPrimary: ${_colorToCode(colorSchemeConfig['onPrimary'] as String?)},');
  buffer.writeln('        secondary: ${_colorToCode(colorSchemeConfig['secondary'] as String?)},');
  buffer.writeln('        onSecondary: ${_colorToCode(colorSchemeConfig['onSecondary'] as String?)},');
  buffer.writeln('        error: ${_colorToCode(colorSchemeConfig['error'] as String?)},');
  buffer.writeln('        onError: ${_colorToCode(colorSchemeConfig['onError'] as String?)},');
  buffer.writeln('        background: ${_colorToCode(colorSchemeConfig['background'] as String?)},');
  buffer.writeln('        onBackground: ${_colorToCode(colorSchemeConfig['onBackground'] as String?)},');
  buffer.writeln('        surface: ${_colorToCode(colorSchemeConfig['surface'] as String?)},');
  buffer.writeln('        onSurface: ${_colorToCode(colorSchemeConfig['onSurface'] as String?)},');
  buffer.writeln('      ),');

  if (brandingSurfaceHex != null) {
    buffer.writeln('      extensions: <ThemeExtension<dynamic>>[');
    buffer.writeln('        CustomColors(brandingSurface: ${_colorToCode(brandingSurfaceHex)}),');
    buffer.writeln('      ],');
  }
  
  buffer.writeln('      textTheme: TextTheme(');
  textThemeConfig.forEach((key, value) {
    if (value is Map<String, dynamic>) {
      buffer.writeln('        $key: ${_textStyleToCode(value)},');
    }
  });
  buffer.writeln('      ),');

  if (appBarThemeConfig != null) {
    buffer.writeln('      appBarTheme: AppBarTheme(');
    if (appBarThemeConfig['backgroundColor'] != null) buffer.writeln('        backgroundColor: ${_colorToCode(appBarThemeConfig['backgroundColor'] as String?)},');
    if (appBarThemeConfig['foregroundColor'] != null) buffer.writeln('        foregroundColor: ${_colorToCode(appBarThemeConfig['foregroundColor'] as String?)},');
    if (appBarThemeConfig['elevation'] != null) buffer.writeln('        elevation: ${appBarThemeConfig['elevation'] as num?},');
    if (appBarThemeConfig['centerTitle'] != null) buffer.writeln('        centerTitle: ${appBarThemeConfig['centerTitle'] as bool?},');
    if (appBarThemeConfig['titleTextStyle'] is Map) {
      buffer.writeln('        titleTextStyle: ${_textStyleToCode(appBarThemeConfig['titleTextStyle'] as Map<String,dynamic>?)},');
    }
    buffer.writeln('      ),');
  }

  if (cardThemeConfig != null) {
    buffer.writeln('      cardTheme: CardThemeData(');
    if (cardThemeConfig['color'] != null) buffer.writeln('        color: ${_colorToCode(cardThemeConfig['color'] as String?)},');
    if (cardThemeConfig['elevation'] != null) buffer.writeln('        elevation: ${cardThemeConfig['elevation'] as num?},');
    if (cardThemeConfig['margin'] is Map) buffer.writeln('        margin: ${_edgeInsetsToCode(cardThemeConfig['margin'] as Map<String,dynamic>?)},');
    if (cardThemeConfig['shape'] is Map) buffer.writeln('        shape: ${_shapeBorderToCode(cardThemeConfig['shape'] as Map<String,dynamic>?)},');
    buffer.writeln('      ),');
  }

  _generateButtonTheme(buffer, 'elevatedButtonTheme', elevatedButtonThemeConfig);
  _generateButtonTheme(buffer, 'textButtonTheme', textButtonThemeConfig, isTextButton: true);
  _generateButtonTheme(buffer, 'outlinedButtonTheme', outlinedButtonThemeConfig, isOutlined: true);

  if (inputDecorationThemeConfig != null) {
    buffer.writeln('      inputDecorationTheme: InputDecorationTheme(');
    if (inputDecorationThemeConfig['filled'] != null) buffer.writeln('        filled: ${inputDecorationThemeConfig['filled'] as bool?},');
    if (inputDecorationThemeConfig['fillColor'] != null) buffer.writeln('        fillColor: ${_colorToCode(inputDecorationThemeConfig['fillColor'] as String?)},');
    if (inputDecorationThemeConfig['border'] is Map) buffer.writeln('        border: ${_inputBorderToCode(inputDecorationThemeConfig['border'] as Map<String,dynamic>?)},');
    if (inputDecorationThemeConfig['focusedBorder'] is Map) buffer.writeln('        focusedBorder: ${_inputBorderToCode(inputDecorationThemeConfig['focusedBorder'] as Map<String,dynamic>?)},');
    if (inputDecorationThemeConfig['labelStyle'] is Map) buffer.writeln('        labelStyle: ${_textStyleToCode(inputDecorationThemeConfig['labelStyle'] as Map<String,dynamic>?)},');
    buffer.writeln('      ),');
  }
  
  if (dialogThemeConfig != null) {
    buffer.writeln('      dialogTheme: DialogThemeData(');
    if (dialogThemeConfig['backgroundColor'] != null) buffer.writeln('        backgroundColor: ${_colorToCode(dialogThemeConfig['backgroundColor'] as String?)},');
    if (dialogThemeConfig['shape'] is Map) buffer.writeln('        shape: ${_shapeBorderToCode(dialogThemeConfig['shape'] as Map<String,dynamic>?)},');
    if (dialogThemeConfig['titleTextStyle'] is Map) buffer.writeln('        titleTextStyle: ${_textStyleToCode(dialogThemeConfig['titleTextStyle'] as Map<String,dynamic>?)},');
    if (dialogThemeConfig['contentTextStyle'] is Map) buffer.writeln('        contentTextStyle: ${_textStyleToCode(dialogThemeConfig['contentTextStyle'] as Map<String,dynamic>?)},');
    buffer.writeln('      ),');
  }

  if (snackBarThemeConfig != null) {
    buffer.writeln('      snackBarTheme: SnackBarThemeData(');
    if (snackBarThemeConfig['backgroundColor'] != null) buffer.writeln('        backgroundColor: ${_colorToCode(snackBarThemeConfig['backgroundColor'] as String?)},');
    if (snackBarThemeConfig['contentTextStyle'] is Map) buffer.writeln('        contentTextStyle: ${_textStyleToCode(snackBarThemeConfig['contentTextStyle'] as Map<String,dynamic>?)},');
    if (snackBarThemeConfig['behavior'] != null) buffer.writeln('        behavior: ${_snackBarBehaviorToCode(snackBarThemeConfig['behavior'] as String?)},');
    buffer.writeln('      ),');
  }
  
  if (iconThemeConfig != null) {
    buffer.writeln('      iconTheme: IconThemeData(');
    if (iconThemeConfig['color'] != null) buffer.writeln('        color: ${_colorToCode(iconThemeConfig['color'] as String?)},');
    buffer.writeln('      ),');
  }

  if (dividerThemeConfig != null) {
    buffer.writeln('      dividerTheme: DividerThemeData(');
    if (dividerThemeConfig['color'] != null) buffer.writeln('        color: ${_colorToCode(dividerThemeConfig['color'] as String?)},');
    if (dividerThemeConfig['thickness'] != null) buffer.writeln('        thickness: ${dividerThemeConfig['thickness'] as num?},');
    if (dividerThemeConfig['space'] != null) buffer.writeln('        space: ${dividerThemeConfig['space'] as num?},');
    buffer.writeln('      ),');
  }

  buffer.writeln('    );');
  buffer.writeln('  }');
  buffer.writeln('}');
  return buffer.toString();
}

String _colorToCode(String? hexColor, {String defaultHex = '#FFFFFFFF', String keyName = 'color'}) {
  final intValue = _parseColorHexValue(hexColor, defaultHex: defaultHex, keyName: keyName);
  return 'Color(0x${intValue.toRadixString(16).padLeft(8, '0')})';
}


String _fontWeightToCode(String? fontWeightStr) {
  if (fontWeightStr == null) return 'null';
  switch (fontWeightStr.toLowerCase()) {
    case 'w100': return 'FontWeight.w100';
    case 'w200': return 'FontWeight.w200';
    case 'w300': return 'FontWeight.w300';
    case 'w400': return 'FontWeight.w400';
    case 'normal': return 'FontWeight.normal';
    case 'w500': return 'FontWeight.w500';
    case 'w600': return 'FontWeight.w600';
    case 'w700': return 'FontWeight.w700';
    case 'bold': return 'FontWeight.bold';
    case 'w800': return 'FontWeight.w800';
    case 'w900': return 'FontWeight.w900';
    default: return 'null';
  }
}

String _textStyleToCode(Map<String, dynamic>? config) {
  if (config == null) return 'null';
  final parts = <String>[];
  if (config['fontSize'] != null) parts.add('fontSize: ${config['fontSize'] as num}');
  if (config['fontWeight'] != null) parts.add('fontWeight: ${_fontWeightToCode(config['fontWeight'] as String?)}');
  if (config['color'] != null) parts.add('color: ${_colorToCode(config['color'] as String?)}');
  return 'TextStyle(${parts.join(', ')})';
}

String _edgeInsetsToCode(Map<String, dynamic>? config) {
  if (config == null) return 'EdgeInsets.zero';
  final type = config['type'] as String?;
  final typeLower = type?.toLowerCase() ?? '';

  if (typeLower.contains('all')) {
    return 'EdgeInsets.all(${config['value'] as num? ?? 0.0})';
  } else if (typeLower.contains('symmetric')) {
    final h = config['horizontal'] as num? ?? 0.0;
    final v = config['vertical'] as num? ?? 0.0;
    return 'EdgeInsets.symmetric(horizontal: $h, vertical: $v)';
  } else if (typeLower.contains('only')) {
    final l = config['left'] as num? ?? 0.0;
    final t = config['top'] as num? ?? 0.0;
    final r = config['right'] as num? ?? 0.0;
    final b = config['bottom'] as num? ?? 0.0;
    return 'EdgeInsets.only(left: $l, top: $t, right: $r, bottom: $b)';
  }
  return 'EdgeInsets.zero';
}

String _borderRadiusToCode(Map<String, dynamic>? config) {
  if (config == null) return 'BorderRadius.zero';
  final type = config['type'] as String?;
  final typeLower = type?.toLowerCase() ?? '';

  if (typeLower.contains('circular')) {
    return 'BorderRadius.circular(${config['radius'] as num? ?? 0.0})';
  }

  return 'BorderRadius.zero';
}

String _shapeBorderToCode(Map<String, dynamic>? config) {
  if (config == null) return 'const RoundedRectangleBorder()';
  final type = config['type'] as String?;
  final typeLower = type?.toLowerCase() ?? '';

  if (typeLower.contains('roundedrectangle')) {
    final borderRadiusConfig = config['borderRadius'] as Map<String, dynamic>?;
    return 'RoundedRectangleBorder(borderRadius: ${_borderRadiusToCode(borderRadiusConfig)})';
  }
  return 'const RoundedRectangleBorder()';
}

String _borderSideToCode(Map<String, dynamic>? config) {
  if (config == null) return 'BorderSide.none';
  final parts = <String>[];
  if (config['color'] != null) parts.add('color: ${_colorToCode(config['color'] as String?)}');
  if (config['width'] != null) parts.add('width: ${config['width'] as num? ?? 1.0}');
  return 'BorderSide(${parts.join(', ')})';
}

String _inputBorderToCode(Map<String, dynamic>? config) {
  if (config == null) return 'null';
  final type = config['type'] as String?;
  if (type == 'outline') {
    final borderSideConfig = config['borderSide'] as Map<String, dynamic>?;
    final borderRadiusConfig = config['borderRadius'] as Map<String, dynamic>?;
    return 'OutlineInputBorder(borderSide: ${_borderSideToCode(borderSideConfig)}, borderRadius: ${_borderRadiusToCode(borderRadiusConfig)})';
  }
  return 'null';
}

String _snackBarBehaviorToCode(String? behaviorStr) {
  if (behaviorStr == 'floating') return 'SnackBarBehavior.floating';
  if (behaviorStr == 'fixed') return 'SnackBarBehavior.fixed';
  return 'null';
}

void _generateButtonTheme(StringBuffer buffer, String themeName, Map<String, dynamic>? config, {bool isTextButton = false, bool isOutlined = false}) {
  if (config == null) return;
  final styleConfig = config['style'] as Map<String, dynamic>?;
  if (styleConfig == null) return;

  buffer.writeln('      $themeName: ${themeName[0].toUpperCase()}${themeName.substring(1)}Data(');
  buffer.writeln('        style: ButtonStyle(');

  if (styleConfig['foregroundColor'] != null) buffer.writeln('          foregroundColor: WidgetStateProperty.all<Color>(${_colorToCode(styleConfig['foregroundColor'] as String?)}),');
  if (styleConfig['backgroundColor'] != null && !isTextButton) buffer.writeln('          backgroundColor: WidgetStateProperty.all<Color>(${_colorToCode(styleConfig['backgroundColor'] as String?)}),');
  if (styleConfig['overlayColor'] != null) buffer.writeln('          overlayColor: WidgetStateProperty.all<Color>(${_colorToCode(styleConfig['overlayColor'] as String?)}),');
  if (styleConfig['elevation'] != null) buffer.writeln('          elevation: WidgetStateProperty.all<double>(${styleConfig['elevation'] as num?}),');
  if (styleConfig['padding'] is Map) buffer.writeln('          padding: WidgetStateProperty.all<EdgeInsetsGeometry>(${_edgeInsetsToCode(styleConfig['padding'] as Map<String,dynamic>?)}),');
  if (styleConfig['textStyle'] is Map && !isOutlined) {
     buffer.writeln('          textStyle: WidgetStateProperty.all<TextStyle>(${_textStyleToCode(styleConfig['textStyle'] as Map<String,dynamic>?)}),');
  }
  if (styleConfig['shape'] is Map) buffer.writeln('          shape: WidgetStateProperty.all<OutlinedBorder>(${_shapeBorderToCode(styleConfig['shape'] as Map<String,dynamic>?)}),');
  if (styleConfig['side'] is Map && isOutlined) {
    buffer.writeln('          side: WidgetStateProperty.all<BorderSide>(${_borderSideToCode(styleConfig['side'] as Map<String,dynamic>?)}),');
  }
  
  buffer.writeln('        ),');
  buffer.writeln('      ),');
}
