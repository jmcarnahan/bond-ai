diff --git a/deployment/terraform-existing-vpc/backend.tf b/deployment/terraform-existing-vpc/backend.tf
index 481b722..310d362 100644
--- a/deployment/terraform-existing-vpc/backend.tf
+++ b/deployment/terraform-existing-vpc/backend.tf
@@ -54,19 +54,41 @@ resource "aws_apprunner_service" "backend" {
           OKTA_DOMAIN = var.okta_domain
           OKTA_CLIENT_ID = var.okta_client_id
           OKTA_CLIENT_SECRET = jsondecode(data.aws_secretsmanager_secret_version.okta_secret.secret_string)["client_secret"]
-          # Okta redirect URI - will be set to the actual backend URL after deployment
-          # We can't reference self here, so using a placeholder that you'll need to update in Okta
-          OKTA_REDIRECT_URI = var.okta_redirect_uri != "" ? var.okta_redirect_uri : "https://BACKEND_URL_PLACEHOLDER/auth/okta/callback"
+          # Okta redirect URI - uses variable to avoid circular dependency
+          OKTA_REDIRECT_URI = var.okta_redirect_uri != "" ? var.okta_redirect_uri : "https://PENDING_BACKEND_URL/auth/okta/callback"
           OKTA_SCOPES = var.okta_scopes
 
-          # JWT redirect URI for frontend - using the stable custom domain
-          # The frontend_fqdn is defined in custom-domain.tf and available before backend deployment
-          JWT_REDIRECT_URI = "https://${local.frontend_fqdn}"
+          # JWT redirect URI for frontend - uses variable to avoid circular dependency
+          JWT_REDIRECT_URI = var.jwt_redirect_uri != "" ? var.jwt_redirect_uri : "*"
 
-          # CORS configuration - include localhost and custom domain
-          # Note: We can't include the App Runner URL here since frontend doesn't exist yet
-          # The custom domain will be the primary access method
-          CORS_ALLOWED_ORIGINS = "${var.cors_allowed_origins},https://${local.frontend_fqdn}"
+          # CORS configuration - uses variable to allow post-deployment tightening
+          CORS_ALLOWED_ORIGINS = var.cors_allowed_origins
+
+          # MCP Server Configuration
+          # Note: URLs come from variables set after first deployment to avoid circular dependency
+          # IMPORTANT: MCP URL must have trailing slash to avoid redirect issues
+          BOND_MCP_CONFIG = var.mcp_atlassian_service_url != "" && var.mcp_atlassian_oauth_secret_name != "" ? jsonencode({
+            mcpServers = {
+              atlassian = {
+                url          = "${var.mcp_atlassian_service_url}/mcp/"
+                transport    = "streamable-http"
+                auth_type    = "oauth2"
+                display_name = "Atlassian"
+                description  = "Connect to Atlassian Jira and Confluence"
+                oauth_config = {
+                  provider      = "atlassian"
+                  client_id     = var.mcp_atlassian_oauth_client_id
+                  client_secret = jsondecode(data.aws_secretsmanager_secret_version.mcp_atlassian_oauth[0].secret_string)["client_secret"]
+                  authorize_url = "https://auth.atlassian.com/authorize"
+                  token_url     = "https://auth.atlassian.com/oauth/token"
+                  scopes        = var.mcp_atlassian_oauth_scopes
+                  redirect_uri  = "${var.backend_service_url}/connections/atlassian/callback"
+                }
+                site_url = "https://api.atlassian.com"
+                cloud_id = var.mcp_atlassian_oauth_cloud_id
+              }
+            }
+          }) : "{}"
         }
       }
     }
